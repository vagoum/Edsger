
** Conflict (shift/reduce) in state 140.
** Token involved: T_Else
** This state is reached from program after reading:

result_type T_Id T_Lparen option(parameter_list) T_Rparen T_Lbrace list(declation) T_If T_Lparen expression T_Rparen T_If T_Lparen expression T_Rparen statement 

** The derivations that appear below have the following common factor:
** (The question mark symbol (?) represents the spot where the derivations begin to differ.)

program 
nonempty_list(declation) T_Eof 
declation 
function_def 
result_type T_Id T_Lparen option(parameter_list) T_Rparen T_Lbrace list(declation) list(statement) T_Rbrace 
                                                                                   statement list(statement) 
                                                                                   (?)

** In state 140, looking ahead at T_Else, reducing production
** option(test3) -> 
** is permitted because of the following sub-derivation:

T_If T_Lparen expression T_Rparen statement option(test3) // lookahead token appears because option(test3) can begin with T_Else
                                  T_If T_Lparen expression T_Rparen statement option(test3) // lookahead token is inherited
                                                                              . 

** In state 140, looking ahead at T_Else, shifting is permitted
** because of the following sub-derivation:

T_If T_Lparen expression T_Rparen statement option(test3) 
                                  T_If T_Lparen expression T_Rparen statement option(test3) 
                                                                              test3 
                                                                              . T_Else statement 

** Conflict (shift/reduce) in state 84.
** Token involved: T_Mul
** This state is reached from program after reading:

type_i T_Id T_Lbracket T_New basic_type T_Mul 

** The derivations that appear below have the following common factor:
** (The question mark symbol (?) represents the spot where the derivations begin to differ.)

program 
nonempty_list(declation) T_Eof 
declation 
variable_declation 
type_i declator_plus 
       declator T_Semicolon 
       T_Id option(test) 
            test 
            T_Lbracket constant_expression T_Rbracket 
                       expression 
                       (?)

** In state 84, looking ahead at T_Mul, reducing production
** list(T_Mul) -> 
** is permitted because of the following sub-derivation:

expression binary_operator expression // lookahead token appears because binary_operator can begin with T_Mul
T_New type_i option(test8) // lookahead token is inherited because option(test8) can vanish
      basic_type list(T_Mul) // lookahead token is inherited
                 T_Mul list(T_Mul) // lookahead token is inherited
                       . 

** In state 84, looking ahead at T_Mul, shifting is permitted
** because of the following sub-derivation:

T_New type_i option(test8) 
      basic_type list(T_Mul) 
                 T_Mul list(T_Mul) 
                       . T_Mul list(T_Mul) 

** Conflict (shift/reduce) in state 83.
** Token involved: T_Mul
** This state is reached from program after reading:

type_i T_Id T_Lbracket T_New basic_type 

** The derivations that appear below have the following common factor:
** (The question mark symbol (?) represents the spot where the derivations begin to differ.)

program 
nonempty_list(declation) T_Eof 
declation 
variable_declation 
type_i declator_plus 
       declator T_Semicolon 
       T_Id option(test) 
            test 
            T_Lbracket constant_expression T_Rbracket 
                       expression 
                       (?)

** In state 83, looking ahead at T_Mul, reducing production
** list(T_Mul) -> 
** is permitted because of the following sub-derivation:

expression binary_operator expression // lookahead token appears because binary_operator can begin with T_Mul
T_New type_i option(test8) // lookahead token is inherited because option(test8) can vanish
      basic_type list(T_Mul) // lookahead token is inherited
                 . 

** In state 83, looking ahead at T_Mul, shifting is permitted
** because of the following sub-derivation:

T_New type_i option(test8) 
      basic_type list(T_Mul) 
                 . T_Mul list(T_Mul) 

** Conflict (shift/reduce) in state 80.
** Tokens involved: T_Sub T_Quest T_PlusEq T_Or T_Neq T_Mul T_Mod_eq T_Mod T_Minus_eq T_Leq T_Le T_Lbrace T_Incr T_Gr T_Geq T_Equal T_Eq T_Dot_eq T_Div_eq T_Div T_Decr T_Comma T_And T_Add
** The following explanations concentrate on token T_Sub.
** This state is reached from program after reading:

type_i T_Id T_Lbracket T_Lparen type_i T_Rparen expression 

** The derivations that appear below have the following common factor:
** (The question mark symbol (?) represents the spot where the derivations begin to differ.)

program 
nonempty_list(declation) T_Eof 
declation 
variable_declation 
type_i declator_plus 
       declator T_Semicolon 
       T_Id option(test) 
            test 
            T_Lbracket constant_expression T_Rbracket 
                       expression 
                       (?)

** In state 80, looking ahead at T_Sub, shifting is permitted
** because of the following sub-derivation:

T_Lparen type_i T_Rparen expression 
                         expression binary_operator expression 
                                    . T_Sub 

** In state 80, looking ahead at T_Sub, reducing production
** expression -> T_Lparen type_i T_Rparen expression 
** is permitted because of the following sub-derivation:

expression binary_operator expression // lookahead token appears because binary_operator can begin with T_Sub
T_Lparen type_i T_Rparen expression . 

** Conflict (shift/reduce) in state 73.
** Token involved: T_Comma
** This state is reached from program after reading:

type_i T_Id T_Lbracket T_Id T_Lparen expression T_Comma expression 

** The derivations that appear below have the following common factor:
** (The question mark symbol (?) represents the spot where the derivations begin to differ.)

program 
nonempty_list(declation) T_Eof 
declation 
variable_declation 
type_i declator_plus 
       declator T_Semicolon 
       T_Id option(test) 
            test 
            T_Lbracket constant_expression T_Rbracket 
                       expression 
                       T_Id T_Lparen option(expression_list) T_Rparen 
                                     expression_list 
                                     expression list(test9) 
                                                (?)

** In state 73, looking ahead at T_Comma, shifting is permitted
** because of the following sub-derivation:

test9 list(test9) 
T_Comma expression 
        expression binary_operator expression 
                   . T_Comma 

** In state 73, looking ahead at T_Comma, reducing production
** test9 -> T_Comma expression 
** is permitted because of the following sub-derivation:

test9 list(test9) // lookahead token appears because list(test9) can begin with T_Comma
T_Comma expression . 

** Conflict (shift/reduce) in state 72.
** Tokens involved: T_True T_Sub T_Null T_Not T_New T_Mul T_Lparen T_Incr T_Id T_False T_Del T_Decr T_Const_String T_Const_Real T_Const_Int T_Const_Char T_Amp T_Add
** The following explanations concentrate on token T_True.
** This state is reached from program after reading:

type_i T_Id T_Lbracket T_Id T_Lparen expression T_Comma 

** The derivations that appear below have the following common factor:
** (The question mark symbol (?) represents the spot where the derivations begin to differ.)

program 
nonempty_list(declation) T_Eof 
declation 
variable_declation 
type_i declator_plus 
       declator T_Semicolon 
       T_Id option(test) 
            test 
            T_Lbracket constant_expression T_Rbracket 
                       expression 
                       T_Id T_Lparen option(expression_list) T_Rparen 
                                     expression_list 
                                     (?)

** In state 72, looking ahead at T_True, reducing production
** binary_operator -> T_Comma 
** is permitted because of the following sub-derivation:

expression list(test9) 
expression binary_operator expression // lookahead token appears because expression can begin with T_True
           T_Comma . 

** In state 72, looking ahead at T_True, shifting is permitted
** because of the following sub-derivation:

expression list(test9) 
           test9 list(test9) 
           T_Comma expression 
                   . T_True 

** Conflict (shift/reduce) in state 67.
** Tokens involved: T_Lbrace T_Comma
** The following explanations concentrate on token T_Lbrace.
** This state is reached from program after reading:

type_i T_Id T_Lbracket T_Del expression 

** The derivations that appear below have the following common factor:
** (The question mark symbol (?) represents the spot where the derivations begin to differ.)

program 
nonempty_list(declation) T_Eof 
declation 
variable_declation 
type_i declator_plus 
       declator T_Semicolon 
       T_Id option(test) 
            test 
            T_Lbracket constant_expression T_Rbracket 
                       expression 
                       (?)

** In state 67, looking ahead at T_Lbrace, shifting is permitted
** because of the following sub-derivation:

T_Del expression 
      expression . T_Lbrace expression T_Rbrace 

** In state 67, looking ahead at T_Lbrace, reducing production
** expression -> T_Del expression 
** is permitted because of the following sub-derivation:

expression T_Lbrace expression T_Rbrace // lookahead token appears
T_Del expression . 

** Conflict (shift/reduce) in state 66.
** Tokens involved: T_Sub T_Quest T_PlusEq T_Or T_Neq T_Mul T_Mod_eq T_Mod T_Minus_eq T_Leq T_Le T_Lbrace T_Incr T_Gr T_Geq T_Equal T_Eq T_Dot_eq T_Div_eq T_Div T_Decr T_Comma T_And T_Add
** The following explanations concentrate on token T_Sub.
** This state is reached from program after reading:

type_i T_Id T_Lbracket unary_operator expression 

** The derivations that appear below have the following common factor:
** (The question mark symbol (?) represents the spot where the derivations begin to differ.)

program 
nonempty_list(declation) T_Eof 
declation 
variable_declation 
type_i declator_plus 
       declator T_Semicolon 
       T_Id option(test) 
            test 
            T_Lbracket constant_expression T_Rbracket 
                       expression 
                       (?)

** In state 66, looking ahead at T_Sub, shifting is permitted
** because of the following sub-derivation:

unary_operator expression 
               expression binary_operator expression 
                          . T_Sub 

** In state 66, looking ahead at T_Sub, reducing production
** expression -> unary_operator expression 
** is permitted because of the following sub-derivation:

expression binary_operator expression // lookahead token appears because binary_operator can begin with T_Sub
unary_operator expression . 

** Conflict (shift/reduce) in state 65.
** Tokens involved: T_Lbrace T_Comma
** The following explanations concentrate on token T_Lbrace.
** This state is reached from program after reading:

type_i T_Id T_Lbracket expression T_Quest expression T_Colon expression 

** The derivations that appear below have the following common factor:
** (The question mark symbol (?) represents the spot where the derivations begin to differ.)

program 
nonempty_list(declation) T_Eof 
declation 
variable_declation 
type_i declator_plus 
       declator T_Semicolon 
       T_Id option(test) 
            test 
            T_Lbracket constant_expression T_Rbracket 
                       expression 
                       (?)

** In state 65, looking ahead at T_Lbrace, shifting is permitted
** because of the following sub-derivation:

expression T_Quest expression T_Colon expression 
                                      expression . T_Lbrace expression T_Rbrace 

** In state 65, looking ahead at T_Lbrace, reducing production
** expression -> expression T_Quest expression T_Colon expression 
** is permitted because of the following sub-derivation:

expression T_Lbrace expression T_Rbrace // lookahead token appears
expression T_Quest expression T_Colon expression . 

** Conflict (shift/reduce) in state 63.
** Tokens involved: T_Sub T_Quest T_PlusEq T_Or T_Neq T_Mul T_Mod_eq T_Mod T_Minus_eq T_Leq T_Le T_Lbrace T_Incr T_Gr T_Geq T_Equal T_Eq T_Dot_eq T_Div_eq T_Div T_Decr T_Comma T_And T_Add
** The following explanations concentrate on token T_Sub.
** This state is reached from program after reading:

type_i T_Id T_Lbracket expression binary_assig expression 

** The derivations that appear below have the following common factor:
** (The question mark symbol (?) represents the spot where the derivations begin to differ.)

program 
nonempty_list(declation) T_Eof 
declation 
variable_declation 
type_i declator_plus 
       declator T_Semicolon 
       T_Id option(test) 
            test 
            T_Lbracket constant_expression T_Rbracket 
                       expression 
                       (?)

** In state 63, looking ahead at T_Sub, shifting is permitted
** because of the following sub-derivation:

expression binary_assig expression 
                        expression binary_operator expression 
                                   . T_Sub 

** In state 63, looking ahead at T_Sub, reducing production
** expression -> expression binary_assig expression 
** is permitted because of the following sub-derivation:

expression binary_operator expression // lookahead token appears because binary_operator can begin with T_Sub
expression binary_assig expression . 

** Conflict (shift/reduce) in state 61.
** Tokens involved: T_Sub T_Quest T_PlusEq T_Or T_Neq T_Mul T_Mod_eq T_Mod T_Minus_eq T_Leq T_Le T_Lbrace T_Incr T_Gr T_Geq T_Equal T_Eq T_Dot_eq T_Div_eq T_Div T_Decr T_Comma T_And T_Add
** The following explanations concentrate on token T_Sub.
** This state is reached from program after reading:

type_i T_Id T_Lbracket expression binary_operator expression 

** The derivations that appear below have the following common factor:
** (The question mark symbol (?) represents the spot where the derivations begin to differ.)

program 
nonempty_list(declation) T_Eof 
declation 
variable_declation 
type_i declator_plus 
       declator T_Semicolon 
       T_Id option(test) 
            test 
            T_Lbracket constant_expression T_Rbracket 
                       expression 
                       (?)

** In state 61, looking ahead at T_Sub, shifting is permitted
** because of the following sub-derivation:

expression binary_operator expression 
                           expression binary_operator expression 
                                      . T_Sub 

** In state 61, looking ahead at T_Sub, reducing production
** expression -> expression binary_operator expression 
** is permitted because of the following sub-derivation:

expression binary_operator expression // lookahead token appears because binary_operator can begin with T_Sub
expression binary_operator expression . 

** Conflict (shift/reduce) in state 33.
** Tokens involved: T_Sub T_Quest T_PlusEq T_Or T_Neq T_Mul T_Mod_eq T_Mod T_Minus_eq T_Leq T_Le T_Lbrace T_Incr T_Gr T_Geq T_Equal T_Eq T_Dot_eq T_Div_eq T_Div T_Decr T_Comma T_And T_Add
** The following explanations concentrate on token T_Sub.
** This state is reached from program after reading:

type_i T_Id T_Lbracket unary_assig expression 

** The derivations that appear below have the following common factor:
** (The question mark symbol (?) represents the spot where the derivations begin to differ.)

program 
nonempty_list(declation) T_Eof 
declation 
variable_declation 
type_i declator_plus 
       declator T_Semicolon 
       T_Id option(test) 
            test 
            T_Lbracket constant_expression T_Rbracket 
                       expression 
                       (?)

** In state 33, looking ahead at T_Sub, shifting is permitted
** because of the following sub-derivation:

unary_assig expression 
            expression binary_operator expression 
                       . T_Sub 

** In state 33, looking ahead at T_Sub, reducing production
** expression -> unary_assig expression 
** is permitted because of the following sub-derivation:

expression binary_operator expression // lookahead token appears because binary_operator can begin with T_Sub
unary_assig expression . 

** Conflict (shift/reduce) in state 7.
** Token involved: T_Id
** This state is reached from program after reading:

type_i 

** The derivations that appear below have the following common factor:
** (The question mark symbol (?) represents the spot where the derivations begin to differ.)

program 
nonempty_list(declation) T_Eof 
declation 
(?)

** In state 7, looking ahead at T_Id, shifting is permitted
** because of the following sub-derivation:

variable_declation 
type_i declator_plus 
       declator T_Semicolon 
       . T_Id option(test) 

** In state 7, looking ahead at T_Id, reducing production
** result_type -> type_i 
** is permitted because of the following sub-derivation:

function_declation 
result_type T_Id T_Lparen option(parameter_list) T_Rparen T_Semicolon // lookahead token appears
type_i . 
