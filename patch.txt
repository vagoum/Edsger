diff --git a/Main.ml b/Main.ml
index 381562c..9f868e7 100755
--- a/Main.ml
+++ b/Main.ml
@@ -13,6 +13,7 @@ let lexbuf = Lexing.from_channel stdin in
 try
         (Parser.program Lexer.lexer lexbuf);
  (*      let _ = print_teliko !ast_tree in*)
+        let _ = print_string("Codegen_start\n") in
     let a=    Codegen.codegen_main !ast_tree 
     in print_module ("a2.ll") a 
 with
diff --git a/Semantic.ml b/Semantic.ml
index 2b17e0c..b3e0748 100755
--- a/Semantic.ml
+++ b/Semantic.ml
@@ -88,6 +88,9 @@ and check_fun_def def  =
   match def with
   | FunDef (entry, param,smth) -> 
                   has_return := false;
+                let ls =( get_fuction_f entry.entry_info).function_prev in
+               (get_fuction_f entry.entry_info).function_paramlist <- ls @ (get_fuction_f entry.entry_info).function_paramlist;
+               let _ = print_int(List.length ls) in
                   List.iter (fun x-> check_stmt entry x) smth;
                  ( if not ( (get_entry_type entry) = TYPE_none) then
                           (if !has_return then () else ignore (error "No return found on fuction")) else ());
@@ -113,7 +116,6 @@ and check_expr2  enrty e=  match e with
         in
         let ls =( get_fuction_f enrty.entry_info).function_prev in
                y.ls<- Some((List.map (fun k1 ->Eid (k1.entry_name)) ls) @j);
-               (get_fuction_f enrty.entry_info).function_paramlist <- ls @ (get_fuction_f enrty.entry_info).function_paramlist;
                ()
             |EPointer a | EUnAdd a | EUnMinus a | Enot a |EArray (_,a) |ECast (_,a)-> check_expr2 enrty a
             | Emult (a, b) | Ediv (a, b)  | Emod (a, b) | Eplus (a, b) | Eminus (a, b) | Elt (a ,b) | Elte (a, b) | Egt (a, b) | Egte ( a, b) | Eeq (a, b) | Eneq (a, b) | Eand (a, b) | Eor (a ,b) | Ecomma (a, b) | EAssignEq (a, b) | EPlusEq (a, b) | EMinusEq (a, b) | EDotEq (a, b) | EDivEq (a ,b) | EModEq (a ,b) -> check_expr2 enrty a ; check_expr2 enrty b 
diff --git a/Symbol.ml b/Symbol.ml
index 5692793..c28ee22 100755
--- a/Symbol.ml
+++ b/Symbol.ml
@@ -189,7 +189,9 @@ let rec lookupEntry id how err =
                     let inf =get_fuction_f (H2.find !curr_func 0) in
                     (*let _ = e2.function_pstatus <-PARDEF_DEFINE in*)
 		let e = newEntry id (ENTRY_parameter inf_p) err in
-          inf.function_prev<- e :: inf.function_prev;
+          inf.function_prev <- e :: inf.function_prev;
+          let _ = print_int(List.length(inf.function_prev));print_string("\n") in
+
           e
                     (*let tmp2 = newParameter id (get_variable_f e1).variable_type (PASS_PREV) (H.find !curr_func 0) false in
                     let _ = endFunctionHeader (H.find !curr_func 0) e2.fuction_result in
diff --git a/_build/Ast.cmt b/_build/Ast.cmt
index 93a97fd..4b6a2cd 100755
Binary files a/_build/Ast.cmt and b/_build/Ast.cmt differ
diff --git a/_build/Codegen.cmi b/_build/Codegen.cmi
index a5add7e..8abd607 100644
Binary files a/_build/Codegen.cmi and b/_build/Codegen.cmi differ
diff --git a/_build/Codegen.cmo b/_build/Codegen.cmo
index e8a70d5..aa5b813 100644
Binary files a/_build/Codegen.cmo and b/_build/Codegen.cmo differ
diff --git a/_build/Codegen.cmt b/_build/Codegen.cmt
index abc3c7e..b1e5b94 100755
Binary files a/_build/Codegen.cmt and b/_build/Codegen.cmt differ
diff --git a/_build/Codegen.cmx b/_build/Codegen.cmx
index c3f377e..4fc3897 100644
Binary files a/_build/Codegen.cmx and b/_build/Codegen.cmx differ
diff --git a/_build/Main.cmi b/_build/Main.cmi
index 14dfd53..0a25f9a 100644
Binary files a/_build/Main.cmi and b/_build/Main.cmi differ
diff --git a/_build/Main.cmo b/_build/Main.cmo
index 641300e..4d15a8e 100644
Binary files a/_build/Main.cmo and b/_build/Main.cmo differ
diff --git a/_build/Main.cmt b/_build/Main.cmt
index de0928b..2771e47 100755
Binary files a/_build/Main.cmt and b/_build/Main.cmt differ
diff --git a/_build/Main.cmx b/_build/Main.cmx
index 81af578..4bdeb48 100644
Binary files a/_build/Main.cmx and b/_build/Main.cmx differ
diff --git a/_build/Main.ml b/_build/Main.ml
index 381562c..9f868e7 100755
--- a/_build/Main.ml
+++ b/_build/Main.ml
@@ -13,6 +13,7 @@ let lexbuf = Lexing.from_channel stdin in
 try
         (Parser.program Lexer.lexer lexbuf);
  (*      let _ = print_teliko !ast_tree in*)
+        let _ = print_string("Codegen_start\n") in
     let a=    Codegen.codegen_main !ast_tree 
     in print_module ("a2.ll") a 
 with
diff --git a/_build/Main.native b/_build/Main.native
index 4c29abb..85ccbe5 100755
Binary files a/_build/Main.native and b/_build/Main.native differ
diff --git a/_build/Main.o b/_build/Main.o
index 5484ba2..ea36c5c 100644
Binary files a/_build/Main.o and b/_build/Main.o differ
diff --git a/_build/Semantic.cmi b/_build/Semantic.cmi
index c7dd30f..b9dab82 100644
Binary files a/_build/Semantic.cmi and b/_build/Semantic.cmi differ
diff --git a/_build/Semantic.cmo b/_build/Semantic.cmo
index f0e2eb3..d1e3555 100644
Binary files a/_build/Semantic.cmo and b/_build/Semantic.cmo differ
diff --git a/_build/Semantic.cmt b/_build/Semantic.cmt
index 36950f0..a3294a7 100755
Binary files a/_build/Semantic.cmt and b/_build/Semantic.cmt differ
diff --git a/_build/Semantic.cmx b/_build/Semantic.cmx
index 726f33d..dc5804b 100644
Binary files a/_build/Semantic.cmx and b/_build/Semantic.cmx differ
diff --git a/_build/Semantic.ml b/_build/Semantic.ml
index b6cf85b..b3e0748 100755
--- a/_build/Semantic.ml
+++ b/_build/Semantic.ml
@@ -88,6 +88,9 @@ and check_fun_def def  =
   match def with
   | FunDef (entry, param,smth) -> 
                   has_return := false;
+                let ls =( get_fuction_f entry.entry_info).function_prev in
+               (get_fuction_f entry.entry_info).function_paramlist <- ls @ (get_fuction_f entry.entry_info).function_paramlist;
+               let _ = print_int(List.length ls) in
                   List.iter (fun x-> check_stmt entry x) smth;
                  ( if not ( (get_entry_type entry) = TYPE_none) then
                           (if !has_return then () else ignore (error "No return found on fuction")) else ());
@@ -113,11 +116,10 @@ and check_expr2  enrty e=  match e with
         in
         let ls =( get_fuction_f enrty.entry_info).function_prev in
                y.ls<- Some((List.map (fun k1 ->Eid (k1.entry_name)) ls) @j);
-               (get_fuction_f enrty.entry_info).function_paramlist <- ls @ (get_fuction_f enrty.entry_info).function_paramlist;
                ()
             |EPointer a | EUnAdd a | EUnMinus a | Enot a |EArray (_,a) |ECast (_,a)-> check_expr2 enrty a
-            | Emult (a, b) | Ediv (a, b)  | Emod (a, b) | Eplus (a, b) | Eminus (a, b) | Elt (a ,b) | Elte (a, b) | Egt (a, b) | Egte ( a, b) | Eeq (a, b) | Eneq (a, b) | Eand (a, b) | Eor (a ,b) | Ecomma (a, b) | EAssignEq (a, b) | EPlusEq (a, b) | EMinusEq (a, b) | EDotEq (a, b) | EDivEq (a ,b) | EModEq (a ,b) -> check_expr2 enrty a ; check_expr2 enrty b ;
-            | EQuestT (a,b,c) -> check_expr2 enrty a ; check_expr2 enrty b; check_expr2 enrty c;
+            | Emult (a, b) | Ediv (a, b)  | Emod (a, b) | Eplus (a, b) | Eminus (a, b) | Elt (a ,b) | Elte (a, b) | Egt (a, b) | Egte ( a, b) | Eeq (a, b) | Eneq (a, b) | Eand (a, b) | Eor (a ,b) | Ecomma (a, b) | EAssignEq (a, b) | EPlusEq (a, b) | EMinusEq (a, b) | EDotEq (a, b) | EDivEq (a ,b) | EModEq (a ,b) -> check_expr2 enrty a ; check_expr2 enrty b 
+            | EQuestT (a,b,c) -> check_expr2 enrty a ; check_expr2 enrty b; check_expr2 enrty c
             |_ -> ();
 and check_expr e = ()
 and check_array_len a = match a with
diff --git a/_build/Semantic.o b/_build/Semantic.o
index c852445..5c85710 100644
Binary files a/_build/Semantic.o and b/_build/Semantic.o differ
diff --git a/_build/Symbol.cmo b/_build/Symbol.cmo
index 6e62bc0..cdb30ff 100644
Binary files a/_build/Symbol.cmo and b/_build/Symbol.cmo differ
diff --git a/_build/Symbol.cmt b/_build/Symbol.cmt
index 0fbbc9e..b1a02d3 100755
Binary files a/_build/Symbol.cmt and b/_build/Symbol.cmt differ
diff --git a/_build/Symbol.ml b/_build/Symbol.ml
index 5692793..c28ee22 100755
--- a/_build/Symbol.ml
+++ b/_build/Symbol.ml
@@ -189,7 +189,9 @@ let rec lookupEntry id how err =
                     let inf =get_fuction_f (H2.find !curr_func 0) in
                     (*let _ = e2.function_pstatus <-PARDEF_DEFINE in*)
 		let e = newEntry id (ENTRY_parameter inf_p) err in
-          inf.function_prev<- e :: inf.function_prev;
+          inf.function_prev <- e :: inf.function_prev;
+          let _ = print_int(List.length(inf.function_prev));print_string("\n") in
+
           e
                     (*let tmp2 = newParameter id (get_variable_f e1).variable_type (PASS_PREV) (H.find !curr_func 0) false in
                     let _ = endFunctionHeader (H.find !curr_func 0) e2.fuction_result in
diff --git a/_build/Symbol.o b/_build/Symbol.o
index dba9c9c..3e25ca8 100644
Binary files a/_build/Symbol.o and b/_build/Symbol.o differ
diff --git a/_build/_digests b/_build/_digests
index 4d476bc..33c7b68 100755
--- a/_build/_digests
+++ b/_build/_digests
@@ -1,54 +1,54 @@
 "Rule: ocaml dependencies ml (%=Hashcons )": "\007\163\211\"\234r;\185L'/.\019\140A\015"
-"Rule: ocaml dependencies ml (%=Symbol )": "\146 o\012\029F\b\243\177\b\194?\160\211j\190"
+"Rule: ocaml dependencies ml (%=Symbol )": "\025I\135xG\189\242\236\236\133\134\165\230V\235\200"
 "Resource: /home/zinc/ntua/compilers/edsger/lamda_lift.ml": "\202\228\255\198\163Q\214\003\179IN\155\134iAE"
 "Rule: ocaml dependencies ml (%=lexer )": "[\212\n\250zI$\253\238\197Y\012\218\197E\209"
 "Rule: ocaml dependencies ml (%=Ast )": "\233\252\147\146T\204\176\160\196\243{\209y\221\202\215"
 "Rule: ocaml: menhir dependencies (%=parser )": "x\228\020\007\1763\222\242\210\172}\025\190\186\005\172"
 "Rule: ocaml dependencies ml (%=lamda_lift )": "e\030\241\031\230\220\134\162\014\231\175<\130\014\128i"
-"Rule: ocaml dependencies ml (%=Main )": "\150](\170/VM\234Jk\016\173\169\237C\208"
+"Rule: ocaml dependencies ml (%=Main )": "\208\190\184\168\007\190p\235\238D\174\191\142%h\189"
 "Rule: ocaml: ml -> cmo & cmi (%=Identifier )": "\185\221EV\030eM!\198b'\240X\161\018a"
-"Rule: ocaml: ml & cmi -> cmx & o (%=Symbol )": "P\1363\t\222\140!\195\197)\226l\177\025\136q"
+"Rule: ocaml: ml & cmi -> cmx & o (%=Symbol )": "\180\135\152\162\133q6A\144\170:\182\255\187S\023"
 "Resource: /home/zinc/ntua/compilers/edsger/lexer.mll": "i*b\186!a\212!\232\231\185\np\182\243$"
-"Rule: ocaml: ml & cmi -> cmx & o (%=lexer )": "\251\223L\174\154y\214E\007\177=m\158\247\248H"
-"Rule: ocaml: ml & cmi -> cmx & o (%=parser )": "y\218\195\134}\192\251\024\150\252Ps\151\137\136\229"
+"Rule: ocaml: ml & cmi -> cmx & o (%=lexer )": "<*\219\026\250#N\t\175qF\204\147\137\173\178"
+"Rule: ocaml: ml & cmi -> cmx & o (%=parser )": "\bP\189\139\138\202\172\224^\244\012\022\r\245\132a"
 "Rule: ocamllex (%=lexer )": "\196\128\171\197Y@\n\029\246mzH\218\164\235\133"
-"Rule: ocaml: cmx* & o* -> native (%=Main )": "\170\001X\006\182\133\129\028*\220|\216\222\196\146\162"
-"Rule: ocaml: ml -> cmo & cmi (%=Codegen )": "\245\155n\171\186T\175=\133RN\177\175`\245\182"
+"Rule: ocaml: cmx* & o* -> native (%=Main )": "\b\154\183/\1448]\215\219e\000n\221\244\170\239"
+"Rule: ocaml: ml -> cmo & cmi (%=Codegen )": "\181\192\221\011/\152\216\178\142\131\210y\136?\159\157"
 "Resource: /home/zinc/ntua/compilers/edsger/Codegen.ml": "\018\213\018\028\007\218|\237V!X\192\218q\226\018"
 "Rule: ocaml dependencies ml (%=parser )": "\229&\224,-o\167\222|\031\136fK\175IE"
 "Rule: ocaml: ml -> cmo & cmi (%=Ast )": "\227\150\199\185\192e\254\029\208e\216\184G\2484R"
 "Rule: ocaml: ml -> cmo & cmi (%=Error )": "\179\167j\170\178\014\179\149=J\235!\t@\224\140"
-"Rule: ocaml: ml -> cmo & cmi (%=Symbol )": "!\237\1580\179\174\234A\224\188\182\240\176\127k\182"
+"Rule: ocaml: ml -> cmo & cmi (%=Symbol )": "\244\235f\186\1372\210+\021\194\184\219&\218\155\227"
 "Rule: ocaml: ml -> cmo & cmi (%=Hashcons )": "W(2\028\027\248\234M\231\135\rs\252\188?g"
 "Rule: ocaml dependencies ml (%=Option )": "\225\211\148\184\217\221\176C\183I\184%P\175\012\156"
 "Rule: ocaml: ml -> cmo & cmi (%=lexer )": "Y\011\000\228\246\b\201\002\217\193\244(L9\248\139"
 "Resource: /home/zinc/ntua/compilers/edsger/parser.mly": "o\001\185\140\230\201n\157i\145\233\215\253&e\004"
 "Rule: ocaml dependencies ml (%=Types )": "\128\132\163\168\254ly?\188R\182\168m\1313\201"
 "Rule: ocaml dependencies ml (%=Codegen )": "AY\143\185%\191\129\022\231\002\131\235\254\169\138U"
-"Resource: /home/zinc/ntua/compilers/edsger/Semantic.ml": "B\213\019\223\138\023\014\162\164+M\133\160b \177"
+"Resource: /home/zinc/ntua/compilers/edsger/Semantic.ml": "\129\199\239b\169\014V\204Y\201J\218 l\242\""
 "Rule: ocaml: ml & cmi -> cmx & o (%=Ast )": "oYu\143\152\223\138\b\237\171\149\0064\235\151\136"
 "Resource: /home/zinc/ntua/compilers/edsger/Types.ml": "`\137'=\154\162\195D\225\"\231V?K8\239"
-"Rule: ocaml: ml & cmi -> cmx & o (%=Semantic )": "\202\137\003\2417\"\176\173\221\155Dx\196\164\181\180"
+"Rule: ocaml: ml & cmi -> cmx & o (%=Semantic )": "\244\"\172\210\254t\012\151\148\148r\133\156\130\130\235"
 "Rule: ocaml dependencies mli (%=parser )": "\1684\244Z\021u\144I\211P\007s,p\189E"
 "Rule: ocaml: ml -> cmo & cmi (%=Option )": "\184\178\000A\150\128d\128\163-z\225)\169E\255"
-"Rule: ocaml: ml -> cmo & cmi (%=Main )": "\177\021$\146\180\180x,9\169\235>\197\230S\131"
+"Rule: ocaml: ml -> cmo & cmi (%=Main )": "\241 \004\155\187\235U7y\n \182\155\178\185S"
 "Rule: ocaml: ml & cmi -> cmx & o (%=Types )": "[\242:\222P\021\030\204j\rH\207\230\199F\132"
-"Rule: ocaml: ml & cmi -> cmx & o (%=Codegen )": "9m\251e\212\213:\187'\002~@M\170\204\249"
+"Rule: ocaml: ml & cmi -> cmx & o (%=Codegen )": "F\1364O\205\180\182\196\211\245\255\254\136\232\175e"
 "Resource: /home/zinc/ntua/compilers/edsger/Option.ml": "\222 \200\252\"\160s^\006\b\140\b\015\150\003\220"
 "Resource: /home/zinc/ntua/compilers/edsger/Error.ml": "\151ykZ.\2122\011\1840J\206\220\252\020~"
-"Rule: ocaml: menhir (%=parser )": "\234\007\"Kd\216\028~\239\174\209\129!\134j\225"
-"Resource: /home/zinc/ntua/compilers/edsger/Symbol.ml": "\251\132\132\131^K\217\195D\189\203\029\023W\128x"
+"Rule: ocaml: menhir (%=parser )": ";\021\128\138\003\021\213\230\019\1665\003\226\1298\220"
+"Resource: /home/zinc/ntua/compilers/edsger/Symbol.ml": "_@\229\214]\018\234\019+\148P\227\227\014\136T"
 "Rule: ocaml: ml & cmi -> cmx & o (%=Error )": "g\216\129\023HC\154\154\154\137Z\209\177\019R\223"
 "Rule: ocaml: ml & cmi -> cmx & o (%=Hashcons )": "\233\226\138\134\248\186}}\223\152\007!\244'\128\245"
-"Rule: ocaml: ml & cmi -> cmx & o (%=Main )": "_ds\169\255'\226\233R$\220HN\184W\160"
+"Rule: ocaml: ml & cmi -> cmx & o (%=Main )": "B\229\164Pe'\128\222\2387k\180\021\216\023A"
 "Rule: ocaml dependencies ml (%=Error )": "mu\253\150\137@\223g\188\192y\229,\174b+"
-"Resource: /home/zinc/ntua/compilers/edsger/Main.ml": "\\\251\161\144\250\206\136\153\179V\215\237.\021\029\194"
+"Resource: /home/zinc/ntua/compilers/edsger/Main.ml": "EA0B}A9\146\016\r\206\192(z\229\221"
 "Rule: ocaml: ml & cmi -> cmx & o (%=lamda_lift )": "\005h1\196\030\229\189\213\127\240\139l\138\192u3"
-"Rule: ocaml dependencies ml (%=Semantic )": "x7H\156+\018&N\177\224\024\020\000\026!\007"
+"Rule: ocaml dependencies ml (%=Semantic )": "\003G\r\223\182Bj\014\248\154\243\129;\248\131\141"
 "Rule: ocaml: ml & cmi -> cmx & o (%=Option )": "\163\170\011\176w\193\211;\178\173\242\197/Km\149"
 "Resource: /home/zinc/ntua/compilers/edsger/Ast.ml": "\166\23924\181o\025\155\133\172?\1796\026*x"
 "Rule: ocaml: ml -> cmo & cmi (%=Types )": "\134+\229\223:\210\207\026\2187\198\171G/\012#"
-"Rule: ocaml: ml -> cmo & cmi (%=Semantic )": "3WF=~\133\169\188\146\239\150\173K\231\208\218"
+"Rule: ocaml: ml -> cmo & cmi (%=Semantic )": "}\215%)\148\190.\168.X\242Bk\175Q\161"
 "Rule: ocaml: mli -> cmi (%=parser )": "\213\243\233\202\178\002\181\194\176z\230_,M\155\174"
 "Rule: ocaml dependencies ml (%=Identifier )": "#\150\250\028\223\186\233\197\2151\231\225\1499\213\150"
 "Resource: /home/zinc/ntua/compilers/edsger/Hashcons.ml": "\228\025\226\2436\t\148\185s\183\235\\\166b\026\137"
diff --git a/_build/_log b/_build/_log
index 5581c85..a8b4068 100644
--- a/_build/_log
+++ b/_build/_log
@@ -44,11 +44,11 @@ File "Semantic.ml", line 22, characters 28-208:
 Warning 8: this pattern-matching is not exhaustive.
 Here is an example of a value that is not matched:
 ENTRY_none
-File "Semantic.ml", line 132, characters 24-679:
+File "Semantic.ml", line 134, characters 24-679:
 Warning 8: this pattern-matching is not exhaustive.
 Here is an example of a value that is not matched:
 ""
-File "Semantic.ml", line 148, characters 33-433:
+File "Semantic.ml", line 150, characters 33-433:
 Warning 8: this pattern-matching is not exhaustive.
 Here is an example of a value that is not matched:
 (Ereal _|Echar _|Eid _|Estring _|Ebool _|ENull|EAmber _|EPointer _|
@@ -57,7 +57,7 @@ Egte (_, _)|Eeq (_, _)|Eneq (_, _)|Enot _|EPlusPlus (_, _)|
 EMinusMinus (_, _)|EAssignEq (_, _)|EPlusEq (_, _)|EMinusEq (_, _)|
 EDivEq (_, _)|EDotEq (_, _)|EModEq (_, _)|ENew (_, _)|EDel _|ECast (_, _)|
 EQuestT (_, _, _)|Eapp (_, _)|ECall (_, _)|EArray (_, _))
-File "Semantic.ml", line 159, characters 8-13:
+File "Semantic.ml", line 161, characters 8-13:
 Warning 39: unused rec flag.
 File "Semantic.ml", line 63, characters 17-18:
 Warning 27: unused variable x.
@@ -77,16 +77,18 @@ File "Semantic.ml", line 80, characters 17-19:
 Warning 27: unused variable x2.
 File "Semantic.ml", line 89, characters 19-24:
 Warning 27: unused variable param.
-File "Semantic.ml", line 95, characters 12-14:
+File "Semantic.ml", line 98, characters 12-14:
 Warning 27: unused variable e1.
-File "Semantic.ml", line 96, characters 12-14:
+File "Semantic.ml", line 99, characters 12-14:
 Warning 27: unused variable e2.
-File "Semantic.ml", line 106, characters 18-22:
+File "Semantic.ml", line 109, characters 18-22:
 Warning 27: unused variable expr.
-File "Semantic.ml", line 110, characters 17-18:
+File "Semantic.ml", line 113, characters 17-18:
 Warning 27: unused variable x.
-File "Semantic.ml", line 122, characters 15-16:
+File "Semantic.ml", line 124, characters 15-16:
 Warning 27: unused variable e.
+# Target: Codegen.cmo, tags: { bin_annot, byte, compile, debug, extension:cmo, extension:ml, file:Codegen.cmo, file:Codegen.ml, implem, ocaml, package(core), package(llvm), package(llvm.analysis), package(ppx_deriving.std), ppx(ppx-jane -as-ppx), quiet, short_paths, thread, traverse }
+ocamlfind ocamlc -c -w A-4-33-40-41-42-43-34-44 -strict-sequence -g -g -bin-annot -short-paths -thread -package ppx_deriving.std -package llvm.analysis -package llvm -package core -ppx 'ppx-jane -as-ppx' -o Codegen.cmo Codegen.ml # cached
 # Target: lexer.mll, tags: { bin_annot, debug, extension:mll, file:lexer.mll, lexer, ocaml, ocamllex, package(core), package(llvm), package(llvm.analysis), package(ppx_deriving.std), ppx(ppx-jane -as-ppx), quiet, short_paths, thread, traverse }
 /usr/bin/ocamllex -q lexer.mll # cached
 # Target: lexer.ml.depends, tags: { bin_annot, debug, extension:ml, file:lexer.ml, ocaml, ocamldep, package(core), package(llvm), package(llvm.analysis), package(ppx_deriving.std), ppx(ppx-jane -as-ppx), quiet, short_paths, thread, traverse }
@@ -98,124 +100,15 @@ ocamlfind ocamldep -package ppx_deriving.std -package llvm.analysis -package llv
 # Target: lamda_lift.cmo, tags: { bin_annot, byte, compile, debug, extension:cmo, extension:ml, file:lamda_lift.cmo, file:lamda_lift.ml, implem, ocaml, package(core), package(llvm), package(llvm.analysis), package(ppx_deriving.std), ppx(ppx-jane -as-ppx), quiet, short_paths, thread, traverse }
 ocamlfind ocamlc -c -w A-4-33-40-41-42-43-34-44 -strict-sequence -g -g -bin-annot -short-paths -thread -package ppx_deriving.std -package llvm.analysis -package llvm -package core -ppx 'ppx-jane -as-ppx' -o lamda_lift.cmo lamda_lift.ml # cached
 # Target: parser.mly, tags: { bin_annot, byte, compile, debug, extension:ml, extension:mly, file:parser.ml, file:parser.mly, infer, menhir, ocaml, package(core), package(llvm), package(llvm.analysis), package(ppx_deriving.std), parser, ppx(ppx-jane -as-ppx), quiet, short_paths, thread, traverse }
-menhir --ocamlc 'ocamlfind ocamlc -w A-4-33-40-41-42-43-34-44 -strict-sequence -g -g -bin-annot -short-paths -thread -package ppx_deriving.std -package llvm.analysis -package llvm -package core -ppx '\''ppx-jane -as-ppx'\''' --infer parser.mly
-+ menhir --ocamlc 'ocamlfind ocamlc -w A-4-33-40-41-42-43-34-44 -strict-sequence -g -g -bin-annot -short-paths -thread -package ppx_deriving.std -package llvm.analysis -package llvm -package core -ppx '\''ppx-jane -as-ppx'\''' --infer parser.mly
-File "parser.mly", line 109, characters 10-16:
-Warning: the token Scomma is unused.
-File "parser.mly", line 257, characters 0-15:
-Warning: symbol expression_list is unreachable from any of the start symbol(s).
-File "parser.mly", line 139, characters 0-5:
-Warning: symbol inFun is unreachable from any of the start symbol(s).
-File "/home/zinc/.opam/system/lib/menhir/standard.mly", line 184, characters 8-12:
-Warning: symbol list(test9) is unreachable from any of the start symbol(s).
-File "parser.mly", line 140, characters 0-6:
-Warning: symbol outFun is unreachable from any of the start symbol(s).
-File "parser.mly", line 135, characters 0-6:
-Warning: symbol test64 is unreachable from any of the start symbol(s).
-File "parser.mly", line 258, characters 0-5:
-Warning: symbol test9 is unreachable from any of the start symbol(s).
-File "parser.mly", line 124, characters 0-9:
-Warning: the precedence level assigned to Array_place is never useful.
-File "parser.mly", line 124, characters 0-9:
-Warning: the precedence level assigned to Fuction_Call is never useful.
-File "parser.mly", line 118, characters 0-9:
-Warning: the precedence level assigned to Incr_dcr_prefix is never useful.
-File "parser.mly", line 109, characters 0-9:
-Warning: the precedence level assigned to Scomma is never useful.
-File "parser.mly", line 124, characters 0-9:
-Warning: the precedence level assigned to T_Lparen is never useful.
-File "parser.mly", line 119, characters 0-9:
-Warning: the precedence level assigned to T_New is never useful.
-File "parser.mly", line 121, characters 0-6:
-Warning: the precedence level assigned to T_Rbracket is never useful.
-File "parser.mly", line 256, characters 56-67:
-Warning: this %prec declaration is never useful.
-File "parser.mly", line 243, characters 33-48:
-Warning: this %prec declaration is never useful.
-File "parser.mly", line 244, characters 33-48:
-Warning: this %prec declaration is never useful.
-File "parser.mly", line 297, characters 34-49:
-Warning: this %prec declaration is never useful.
-File "parser.mly", line 298, characters 34-49:
-Warning: this %prec declaration is never useful.
-File "parser.mly", line 204, characters 61-73:
-Warning: this %prec declaration is never useful.
-Warning: 63 states have shift/reduce conflicts.
-Warning: 181 shift/reduce conflicts were arbitrarily resolved.
+menhir --ocamlc 'ocamlfind ocamlc -w A-4-33-40-41-42-43-34-44 -strict-sequence -g -g -bin-annot -short-paths -thread -package ppx_deriving.std -package llvm.analysis -package llvm -package core -ppx '\''ppx-jane -as-ppx'\''' --infer parser.mly # cached
 # Target: parser.mli.depends, tags: { bin_annot, debug, extension:mli, file:parser.mli, ocaml, ocamldep, package(core), package(llvm), package(llvm.analysis), package(ppx_deriving.std), ppx(ppx-jane -as-ppx), quiet, short_paths, thread, traverse }
 ocamlfind ocamldep -package ppx_deriving.std -package llvm.analysis -package llvm -package core -ppx 'ppx-jane -as-ppx' -modules parser.mli > parser.mli.depends # cached
 # Target: parser.cmi, tags: { bin_annot, byte, compile, debug, extension:mli, file:parser.mli, interf, ocaml, package(core), package(llvm), package(llvm.analysis), package(ppx_deriving.std), ppx(ppx-jane -as-ppx), quiet, short_paths, thread, traverse }
 ocamlfind ocamlc -c -w A-4-33-40-41-42-43-34-44 -strict-sequence -g -g -bin-annot -short-paths -thread -package ppx_deriving.std -package llvm.analysis -package llvm -package core -ppx 'ppx-jane -as-ppx' -o parser.cmi parser.mli # cached
 # Target: lexer.cmo, tags: { bin_annot, byte, compile, debug, extension:cmo, extension:ml, file:lexer.cmo, file:lexer.ml, implem, ocaml, package(core), package(llvm), package(llvm.analysis), package(ppx_deriving.std), ppx(ppx-jane -as-ppx), quiet, short_paths, thread, traverse }
 ocamlfind ocamlc -c -w A-4-33-40-41-42-43-34-44 -strict-sequence -g -g -bin-annot -short-paths -thread -package ppx_deriving.std -package llvm.analysis -package llvm -package core -ppx 'ppx-jane -as-ppx' -o lexer.cmo lexer.ml # cached
-# Target: Codegen.cmo, tags: { bin_annot, byte, compile, debug, extension:cmo, extension:ml, file:Codegen.cmo, file:Codegen.ml, implem, ocaml, package(core), package(llvm), package(llvm.analysis), package(ppx_deriving.std), ppx(ppx-jane -as-ppx), quiet, short_paths, thread, traverse }
-ocamlfind ocamlc -c -w A-4-33-40-41-42-43-34-44 -strict-sequence -g -g -bin-annot -short-paths -thread -package ppx_deriving.std -package llvm.analysis -package llvm -package core -ppx 'ppx-jane -as-ppx' -o Codegen.cmo Codegen.ml
-+ ocamlfind ocamlc -c -w A-4-33-40-41-42-43-34-44 -strict-sequence -g -g -bin-annot -short-paths -thread -package ppx_deriving.std -package llvm.analysis -package llvm -package core -ppx 'ppx-jane -as-ppx' -o Codegen.cmo Codegen.ml
-File "Codegen.ml", line 29, characters 24-512:
-Warning 8: this pattern-matching is not exhaustive.
-Here is an example of a value that is not matched:
-TYPE_byte
-File "Codegen.ml", line 39, characters 24-91:
-Warning 8: this pattern-matching is not exhaustive.
-Here is an example of a value that is not matched:
-(TYPE_none|TYPE_int|TYPE_byte|TYPE_proc|TYPE_bool|TYPE_char|TYPE_double|
-TYPE_void|TYPE_pointer _)
-File "Codegen.ml", line 39, characters 8-22:
-Warning 39: unused rec flag.
-File "Codegen.ml", line 46, characters 28-330:
-Warning 8: this pattern-matching is not exhaustive.
-Here is an example of a value that is not matched:
-(TYPE_none|TYPE_byte|TYPE_array (_, _)|TYPE_proc|TYPE_pointer _)
-File "Codegen.ml", line 124, characters 7-3149:
-Warning 8: this pattern-matching is not exhaustive.
-Here is an example of a value that is not matched:
-Eapp (_, _)
-File "Codegen.ml", line 259, characters 27-895:
-Warning 8: this pattern-matching is not exhaustive.
-Here is an example of a value that is not matched:
-Neq
-File "Codegen.ml", line 278, characters 16-774:
-Warning 8: this pattern-matching is not exhaustive.
-Here is an example of a value that is not matched:
-(And|Or|Neq)
-File "Codegen.ml", line 319, characters 159-254:
-Warning 8: this pattern-matching is not exhaustive.
-Here is an example of a value that is not matched:
-(ENTRY_none|ENTRY_variable _|ENTRY_function _|ENTRY_temporary _)
-File "Codegen.ml", line 329, characters 18-63:
-Warning 8: this pattern-matching is not exhaustive.
-Here is an example of a value that is not matched:
-At_start _
-File "Codegen.ml", line 315, characters 34-1891:
-Warning 8: this pattern-matching is not exhaustive.
-Here is an example of a value that is not matched:
-(VarDecl _|FunDecl _)
-File "Codegen.ml", line 355, characters 31-732:
-Warning 8: this pattern-matching is not exhaustive.
-Here is an example of a value that is not matched:
-(Eint _|Ereal _|Echar _|Estring _|Ebool _|ENull|EUnAdd _|EUnMinus _|
-Eplus (_, _)|Eminus (_, _)|Ediv (_, _)|Emult (_, _)|Emod (_, _)|Eand (_, _)|
-Eor (_, _)|Ecomma (_, _)|Elt (_, _)|Elte (_, _)|Egt (_, _)|Egte (_, _)|
-Eeq (_, _)|Eneq (_, _)|Enot _|EPlusPlus (_, _)|EMinusMinus (_, _)|
-EAssignEq (_, _)|EPlusEq (_, _)|EMinusEq (_, _)|EDivEq (_, _)|EDotEq (_, _)|
-EModEq (_, _)|ENew (_, _)|EDel _|ECast (_, _)|EQuestT (_, _, _)|Eapp (_, _)|
-ECall (_, _))
-File "Codegen.ml", line 366, characters 39-583:
-Warning 8: this pattern-matching is not exhaustive.
-Here is an example of a value that is not matched:
-(TYPE_none|TYPE_byte|TYPE_proc)
-File "Codegen.ml", line 40, characters 23-24:
-Warning 27: unused variable b.
-File "Codegen.ml", line 63, characters 12-20:
-Warning 26: unused variable then_val.
-File "Codegen.ml", line 67, characters 12-20:
-Warning 26: unused variable else_val.
-File "Codegen.ml", line 245, characters 20-21:
-Warning 27: unused variable a.
-File "Codegen.ml", line 319, characters 12-18:
-Warning 26: unused variable params.
 # Target: Main.cmo, tags: { bin_annot, byte, compile, debug, extension:cmo, extension:ml, file:Main.cmo, file:Main.ml, implem, ocaml, package(core), package(llvm), package(llvm.analysis), package(ppx_deriving.std), ppx(ppx-jane -as-ppx), quiet, short_paths, thread, traverse }
-ocamlfind ocamlc -c -w A-4-33-40-41-42-43-34-44 -strict-sequence -g -g -bin-annot -short-paths -thread -package ppx_deriving.std -package llvm.analysis -package llvm -package core -ppx 'ppx-jane -as-ppx' -o Main.cmo Main.ml
+ocamlfind ocamlc -c -w A-4-33-40-41-42-43-34-44 -strict-sequence -g -g -bin-annot -short-paths -thread -package ppx_deriving.std -package llvm.analysis -package llvm -package core -ppx 'ppx-jane -as-ppx' -o Main.cmo Main.ml # cached
 # Target: Error.cmx, tags: { bin_annot, compile, debug, extension:cmx, extension:ml, file:Error.cmx, file:Error.ml, implem, native, ocaml, package(core), package(llvm), package(llvm.analysis), package(ppx_deriving.std), ppx(ppx-jane -as-ppx), quiet, short_paths, thread, traverse }
 ocamlfind ocamlopt -c -w A-4-33-40-41-42-43-34-44 -strict-sequence -g -g -bin-annot -short-paths -thread -package ppx_deriving.std -package llvm.analysis -package llvm -package core -ppx 'ppx-jane -as-ppx' -o Error.cmx Error.ml # cached
 # Target: Hashcons.cmx, tags: { bin_annot, compile, debug, extension:cmx, extension:ml, file:Hashcons.cmx, file:Hashcons.ml, implem, native, ocaml, package(core), package(llvm), package(llvm.analysis), package(ppx_deriving.std), ppx(ppx-jane -as-ppx), quiet, short_paths, thread, traverse }
@@ -241,11 +134,11 @@ File "Semantic.ml", line 22, characters 28-208:
 Warning 8: this pattern-matching is not exhaustive.
 Here is an example of a value that is not matched:
 ENTRY_none
-File "Semantic.ml", line 132, characters 24-679:
+File "Semantic.ml", line 134, characters 24-679:
 Warning 8: this pattern-matching is not exhaustive.
 Here is an example of a value that is not matched:
 ""
-File "Semantic.ml", line 148, characters 33-433:
+File "Semantic.ml", line 150, characters 33-433:
 Warning 8: this pattern-matching is not exhaustive.
 Here is an example of a value that is not matched:
 (Ereal _|Echar _|Eid _|Estring _|Ebool _|ENull|EAmber _|EPointer _|
@@ -254,7 +147,7 @@ Egte (_, _)|Eeq (_, _)|Eneq (_, _)|Enot _|EPlusPlus (_, _)|
 EMinusMinus (_, _)|EAssignEq (_, _)|EPlusEq (_, _)|EMinusEq (_, _)|
 EDivEq (_, _)|EDotEq (_, _)|EModEq (_, _)|ENew (_, _)|EDel _|ECast (_, _)|
 EQuestT (_, _, _)|Eapp (_, _)|ECall (_, _)|EArray (_, _))
-File "Semantic.ml", line 159, characters 8-13:
+File "Semantic.ml", line 161, characters 8-13:
 Warning 39: unused rec flag.
 File "Semantic.ml", line 63, characters 17-18:
 Warning 27: unused variable x.
@@ -274,15 +167,15 @@ File "Semantic.ml", line 80, characters 17-19:
 Warning 27: unused variable x2.
 File "Semantic.ml", line 89, characters 19-24:
 Warning 27: unused variable param.
-File "Semantic.ml", line 95, characters 12-14:
+File "Semantic.ml", line 98, characters 12-14:
 Warning 27: unused variable e1.
-File "Semantic.ml", line 96, characters 12-14:
+File "Semantic.ml", line 99, characters 12-14:
 Warning 27: unused variable e2.
-File "Semantic.ml", line 106, characters 18-22:
+File "Semantic.ml", line 109, characters 18-22:
 Warning 27: unused variable expr.
-File "Semantic.ml", line 110, characters 17-18:
+File "Semantic.ml", line 113, characters 17-18:
 Warning 27: unused variable x.
-File "Semantic.ml", line 122, characters 15-16:
+File "Semantic.ml", line 124, characters 15-16:
 Warning 27: unused variable e.
 # Target: parser.ml.depends, tags: { bin_annot, debug, extension:ml, file:parser.ml, ocaml, ocamldep, package(core), package(llvm), package(llvm.analysis), package(ppx_deriving.std), ppx(ppx-jane -as-ppx), quiet, short_paths, thread, traverse }
 ocamlfind ocamldep -package ppx_deriving.std -package llvm.analysis -package llvm -package core -ppx 'ppx-jane -as-ppx' -modules parser.ml > parser.ml.depends # cached
diff --git a/_build/parser.cmt b/_build/parser.cmt
index b9adc08..27a0c2e 100755
Binary files a/_build/parser.cmt and b/_build/parser.cmt differ
diff --git a/_build/parser.cmx b/_build/parser.cmx
index e14495e..f278c05 100644
Binary files a/_build/parser.cmx and b/_build/parser.cmx differ
diff --git a/_build/parser.o b/_build/parser.o
index 6e1dfe4..0aca34b 100644
Binary files a/_build/parser.o and b/_build/parser.o differ
diff --git a/codegen.ml b/codegen.ml
deleted file mode 100644
index c5525dd..0000000
--- a/codegen.ml
+++ /dev/null
@@ -1,179 +0,0 @@
-open Llvm
-open Ast 
-open Types 
-exception Error of string
-
-let context = global_contect ()
-let the_module = create_module context "My cmp "
-let builder = builder context
-let named_values:(string, llvalue) Hashtbl.t =Hashtbl.create 10
-type binary_ops = Plus|Minus|Div|Mult|Mod|And|Or|Comma|Lt|Lte|Eq|Neq|Gt|Gte
-let create_entry_block_alloca func var_name = 
-        let builder =builder_at (instr_begin (entry_block func)) in
-        build_alloca (var_type ) var_name builder
-let rec ltype_of_type = function 
-        | TYPE_int ->  i32_type context 
-        | TYPE_bool -> i1_type context
-        | TYPE_char -> i8_type context 
-        | TYPE_double -> double_type context 
-        | TYPE_void -> void_type context
-        | TYPE_pointer t -> pointer_type (ltype_of_type t)
-        | TYPE_array (a,b) -> array_type (ltype_of_type a) b
-        | TYPE_proc -> ltype_of_type TYPE_void
-let default_val_type smth = match smth with 
-        | TYPE_int ->  const_int (ltype_of_type smth) 0
-        | TYPE_bool -> cont_int (ltype_of_type smth) 0
-        | TYPE_char -> cont_int (ltype_of_type smth) 0
-        | TYPE_double -> const_float (ltype_of_type smth) 0.0
-        | TYPE_void -> const_int (ltype_of_type smth) 0
-let rec codegen_stmt stmt builder= match stmt with 
-        SExpr (Some a) ->  codegen_expr a
-        |SNewblock a -> List.map (codegen_stmt builder) a
-        |Sfor (a,b,c,d,e,f) -> codegen_for_loop a b c d e f
-        |Sif (a,b,c) -> let fanc = let lval =  codegen_expr a builder in 
-        let cond_val = build_fcmp Fcmp.One lval (const_float (ltype_of_type TYPE_double) 0.0) "ifcond" builder in
-        let start_bb = insertion_block builder in
-        let the_function =block_parent start_bb in
-        let then_bb =append_block context "then" the_function in
-        position_at_end then_bb builder;
-        let then_val =codegen_stmt b in
-        let new_then_bb =insertion_block builder in
-        let else_bb = append_block context "else" the_function in
-        position_at_end else_bb builder;
-        let else_val1 = Option.map codegen_stmt c in
-        let else_val = if Option.is_some else_val1 then Option.get else_val1 else codegen_expr (Enull) in
-        let new_else_bb =insertion_block builder in
-        let merge_bb= append_block context "ifcond" the_function in
-        position_at_end merge_bb builder;
-        let incoming = [(then_val,new_then_bb);(else_val,new_else_bb)] in
-        let phi = build_phi incoming "iftmp" builder in
-        position_at_end start_bb builder;
-        ignore(build_cond_br cond_val then_bb else_bb builder);
-        position_at_end new_then_bb bulder; ignore(build_br merge_bb builder); 
-        position_at_end new_else_bb bulder; ignore(build_br merge_bb builder); 
-        phi in fanc
-        |Sreturn (Some a) -> build_ret (codegen_expr a builder) builder
-        |Sreturn _ -> build_ret_void builder 
-        |SBreak (Some a) ->
-        |SCont (Some a) ->
-        |SBreak _ ->
-        |Scont _ ->
-        |_ -> codegen_expr (Enull) builder;;
-and codegen_for_loop 
-and let rec codegen_expr builder= match expr with
-        |Eint a -> const_int (ltype_of_type TYPE_int) a
-        |Ereal a -> const_float (ltype_of_type TYPE_double) a
-        |Echar a -> const_int (ltype_of_type TYPE_char) (Char.to_int a)
-        |Eid a ->let v= try Hashtbl.find named_values a with |Not_found -> raise (Error "uknown variable name") in build_load v name builder
-        |Estring a-> build_global_stringptr s "tmp" builder
-        |Ebool a -> const_int (ltype_of_type TYPE_bool) (if a then 1 else 0)
-        |Enull -> (*NOP *)
-        |EAmber a ->
-        |EPointer a->
-        |EUnAdd a->
-        |EUnMinus a -> let lval = codegen_expr a builder in let type_is = (* type get*)
-                                in let type_m m= match m  with 
-                                TYPE_int -> build_neg lval "int_unoptmp" builder
-                                | TYPE_double -> build_fneg lval "flt_unotmp" builder
-                                in type_m type_is
-        |Eplus (a,b) -> codegen_binary a b Plus builder
-        |Eminus (a,b) -> codegen_binary a b Minus builder
-        |Ediv (a,b) ->codegen_binary a b Div builder
-        |Emult (a,b) -> codegen_binary a b Mult builder 
-        |Emod (a,b) -> codegen_binary a b Mod builder 
-        |Eand (a,b) -> codegen_binary a b And builder 
-        |EOr (a,b) -> codegen_binary a b Or builder
-        |Ecomma (a,b) -> codegen_binary a b Comma builder 
-        |Elt (a,b) -> codegen_expr a b Lt builder 
-        |Elte (a,b) -> codegen_expr a b Lte builder 
-        |Egt (a,b) -> codegen_expr a b Gt builder 
-        |Egte (a,b) -> codegen_expr a b Gte builder 
-        |Eeq (a,b) -> codegen_expr a b Eq builder 
-        |Enot a -> let lval = codegen_expr a builder in build_not lval "nottmp" builder 
-        |EplusPlus (a,b)-> 
-        |EMinusMinus (a,b)-> 
-        |EAssignEq (a,b)-> codegen_assign (codegen_expr a builder) (codegen_expr b builder) builder 
-        |EplusEq (a,b) -> let value = codegen_expr Eplus(a,b) builder in codegen_assign (codegen_expr a builder ) value builder
-        |EMinusEq (a,b) -> let value = codegen_expr EMinus(a,b) builder in codegen_assign (codegen_expr a builder) value builder
-        |EDivEq (a,b) -> let value = codegen_expr Ediv(a,b) builder in codegen_assign (codegen_expr a builder) value builder
-        |EDotEq (a,b) -> let value = codegen_expr Emult(a,b) builder in codegen_assign (codegen_expr a builder) value builder
-        |EModEq (a,b) -> let value = codegen_expr Emod(a,b) builder in codegen_assign (codegen_expr a builder) value builder
-        |Enew (a,b) ->
-        |EDel a ->
-        |Ecast (a,b)->
-        |Eapp
-        |ECall
-        |EArray (a,b)
-and let rec codegen_assign e1 e2 = 
-
-
-and let rec codegen_binary e1 e2 expr  builder= 
-        let type1 =  in
-        let type2 =  in
-        let e1n = codegen_expr e1 builder in
-        let e2n = codegen_expr e2  builder in
-        let int_fun expr = match expr with
-                Plus -> build_add e1n e2n "addtmp" builder 
-                |Minus ->build_sub e1n e2n "subtmp" builder
-                |Div ->build_sdiv e1n e2n "divtmp" builder
-                |Mult ->build_mul e1n e2n "multmp" builder
-                |Mod -> build_srem e1n e2n "sremtmp" builder
-                |And -> build_and e1n e2n "andtmp" builder
-                |Or -> build_or e1n e2n "ortmp" builder
-                |Lt ->build_icmp Icmp.Slt e1n e2n "lttmp" builder
-                |Lte ->build_icmp Icmp.Sle e1n e2n "ltetmp" builder
-                |Gt -> build_icmp Icmp.Sgt e1n e2n "gttmp" builder
-                |Gte -> build_icmp Icmp.Sge e1n e2n "gtetmp" builder
-                |Eq -> build_icmp Icmp.Eq e1n e2n "equaltmp" builder
-        in
-        let float_fun expr = match expr with
-                Plus -> build_fadd e1n e2n "addtmp" builder 
-                |Minus ->build_fsub e1n e2n "subtmp" builder
-                |Div ->build_fsdiv e1n e2n "divtmp" builder
-                |Mult ->build_fmul e1n e2n "multmp" builder
-                |Mod -> build_fsrem e1n e2n "sremtmp" builder
-                |Lt ->build_ficmp Icmp.Slt e1n e2n "lttmp" builder
-                |Lte ->build_ficmp Icmp.Sle e1n e2n "ltetmp" builder
-                |Gt -> build_ficmp Icmp.Sgt e1n e2n "gttmp" builder
-                |Gte -> build_ficmp Icmp.Sge e1n e2n "gtetmp" builder
-                |Eq -> build_ficmp Icmp.Eq e1n e2n "equaltmp" builder
-        in
-            if () int_fun expr else flaot_fun expr ;;
-
-let codegen_func func =
-        let name = func.entry_name in
-        let parametres = List.map (fun x-> ltype_of_type x.entry_info.parameter_type) (func.entry_info.function_paramlist) in
-        let fuction_type = function_type (ltype_of_type func.entry_info.function_result) (Array.of_list parametres) in
-        define_function name function_type the_module ;;
-
-let make_function func1 = match func1 with FunDef (func,b,c) -> 
-        let name = func.entry_name in
-        let f = Option.get (lookup_function name the_module) in
-        let builder = builder_at_end context (entry_block f) in
-        let params = ... in
-        let _  = List.map codegen_stmt c builder in
-        let last= match block_end f with After (block) -> block in
-        let return= return_type (type_of f) in
-        match (instr_end last) with
-        After(ins)-> if ((instr_opcode ins) = Opcode.Ret) then ()
-        else 
-                if return =(void_type context )  then ignore (build_ret_void); else 
-                        ignore(build_ret (default_val_type TYPE_int) builder)
-       |At_start(_) ->
-                if return =(void_type context )  then ignore (build_ret_void); else 
-                        ignore(build_ret (default_val_type TYPE_int) builder);;
-
-
-let getAdreess expr builder =  match expr with 
- Eid(x) ->  findinHash x
- |EAmber (x)->  let y = findinHash x in
-        let dereference = build_struct_gep y 0 "tmp" in build_load dereference "tmp" builder
- |EPointer (x)-> let y = findinHash x in let load_ = build_load y "temp" builder in
-        let dereference = build_struct_gep load_ 0 "tmp" in dereference 
- |EArray(x,y) -> let index = codegen_expr y builder in  let tmp_val = findinHash x in
- let dereference = build_gep tmp_val  [|0;index|] "arrayval" builder in dereference 
-
-let codegen_main main = 
-
-
-
diff --git a/libs/edsger_lib b/libs/edsger_lib
--- a/libs/edsger_lib
+++ b/libs/edsger_lib
@@ -1 +1 @@
-Subproject commit 5ceda5df00c2b6cf79a16bbc82d1c6add6b554c1
+Subproject commit 5ceda5df00c2b6cf79a16bbc82d1c6add6b554c1-dirty
diff --git a/main.ml b/main.ml
deleted file mode 100755
index c3a3c2d..0000000
--- a/main.ml
+++ /dev/null
@@ -1,48 +0,0 @@
-(*let main =
-  try
-    Parser.program Lexer.lexer (Lexing.from_channel stdin);
-    exit 0
-  with Parsing.Parse_error ->
-    Printf.eprintf "smth";
-    exit 1*)
-let main = 
-let lexbuf = Lexing.from_channel stdin in
-try
- Parser.program Lexer.lexer lexbuf
-with
-| Failure msg -> print_endline ("Failure in " ^ msg)
-| Parser.Error -> print_endline "Parse error"
-| End_of_file ->
- print_endline "Parse error: unexpected end of string"
-(*
-open Core.Std
-open Lexer
-open Lexing
-
-let print_position outx lexbuf =
-  let pos = lexbuf.lex_curr_p in
-  fprintf outx "%s:%d:%d" pos.pos_fname
-    pos.pos_lnum (pos.pos_cnum - pos.pos_bol + 1)
-
-let parse_with_error lexbuf =
-  try Parser.program Lexer.lexer lexbuf with
-  | Lexer.SyntaxError msg ->
-    fprintf stderr "%a: %s\n" print_position lexbuf msg;
-    None
-  | Parser.Error ->
-    fprintf stderr "%a: syntax error\n" print_position lexbuf;
-    exit (-1)
-let rec parse_and_print lexbuf =
-  match parse_with_error lexbuf with
-  | Some value ->
-    printf "%a\n" Json.output_value value;
-    parse_and_print lexbuf
-  | None -> ()
-
-let loop filename () =
-  let inx = In_channel.create filename in
-  let lexbuf = Lexing.from_channel inx in
-  lexbuf.lex_curr_p <- { lexbuf.lex_curr_p with pos_fname = filename };
-  parse_and_print lexbuf;
-  In_channel.close inx*)
-        
